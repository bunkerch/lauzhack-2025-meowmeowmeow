// Client-side ZK proof verification using snarkjs
import * as snarkjs from 'snarkjs';
import { ProofSchema, PublicSignalsSchema, type ProofData, type QRCodeData } from '../schemas/validation';

// REAL verification key generated from circom circuit!
// Generated by setup.sh from circuits/verification_key.json
const VERIFICATION_KEY = {
  "protocol": "groth16",
  "curve": "bn128",
  "nPublic": 4,
  "vk_alpha_1": [
   "16341940248595762048265541594530231770569794186800541243314051339424804088895",
   "3515811496933937882606350217128046498180117157331869070212900468080068018529",
   "1"
  ],
  "vk_beta_2": [
   [
    "12468673609755131754306704531949679631864409286151351630067529886272076254803",
    "8693753153308058634949986035242941456918725299671993986500395609200829762816"
   ],
   [
    "1178181305721482386225397576609236994087366338544956281003093898502838623053",
    "4989121995217450427933381789716358412393701087521578385041837342222563474500"
   ],
   [
    "1",
    "0"
   ]
  ],
  "vk_gamma_2": [
   [
    "10857046999023057135944570762232829481370756359578518086990519993285655852781",
    "11559732032986387107991004021392285783925812861821192530917403151452391805634"
   ],
   [
    "8495653923123431417604973247489272438418190587263600148770280649306958101930",
    "4082367875863433681332203403145435568316851327593401208105741076214120093531"
   ],
   [
    "1",
    "0"
   ]
  ],
  "vk_delta_2": [
   [
    "18824945983142932891454954992511003183491695752771898062272787234909645114024",
    "10396605982099835141834772393794167752124543590627228074382538243575234542821"
   ],
   [
    "2292818279680630041434429251754176849511932848172004047670337272724680372024",
    "19565136198026307607780261730024929442919732027263128924238531337511690778668"
   ],
   [
    "1",
    "0"
   ]
  ],
  "vk_alphabeta_12": [
   [
    [
     "20610641361346560264635330425919260150695500011216253683308889107576636663265",
     "16979604561972413467816490609995465746199152824332364045968051287256540709068"
    ],
    [
     "3765601064678183847746859462891442011329705991174108254980174356555450062502",
     "14860555351067115856691354849193129672747705180320045003432204294123983985082"
    ],
    [
     "12968394689973841892022803114364034575527680682583530004266234285979882175342",
     "13923117314918155928270886188725500803590566982896007259554504846723423771632"
    ]
   ],
   [
    [
     "1395103069495513479651322266957063871071638557300062808388022092521670854204",
     "12322448929140483441286796998207887835241424793486080562554068447590422469021"
    ],
    [
     "15707498899131556237657943111865781870734330846637567592811666872883407104214",
     "2445121322492882730911076844996971719165738550354543622663780247521784555842"
    ],
    [
     "15245800328947984020781110925126523235764927309504806732749312768822221773415",
     "13834373865844965575327636077507203145061190049061504168918620988774589689486"
    ]
   ]
  ],
  "IC": [
   [
    "1172782392900672100689125812589994004627590235139894564277343595651564216101",
    "12231407922185676291338850782434761882680376489526912220920161550004842499190",
    "1"
   ],
   [
    "16203747227395839945750292449223367254090428783237012717182946289533067191902",
    "12734238009567633368447642981835205842392768829168078316789588925753845842020",
    "1"
   ],
   [
    "17377738702815115251967900594245307224425439642888967102724472252225275980047",
    "3005372043415358275771495236278284797063780208701176129071966151865692466617",
    "1"
   ],
   [
    "11591874771578580589752893971164840087263288569566026233243987566049235392581",
    "21706307584768897830740556794955463297420795043982193547222743188328996449310",
    "1"
   ],
   [
    "1452653259090537705371794635109877543204766462546929333089279171289482357609",
    "2320366418573614408233242804157169805209975855687315425003457509499365861790",
    "1"
   ]
  ]
 }

/**
 * Verify a zero-knowledge proof using snarkjs
 * This actually verifies the cryptographic proof!
 */
export async function verifyProofOffline(
  proof: ProofData,
  publicSignals: any[]
): Promise<boolean> {
  try {
    console.log('üîê Verifying ZK proof with snarkjs...');
    
    // Validate using Zod schemas instead of manual checks
    const proofValidation = ProofSchema.safeParse(proof);
    if (!proofValidation.success) {
      console.error('Invalid proof structure:', proofValidation.error.format());
      return false;
    }

    const signalsValidation = PublicSignalsSchema.safeParse(publicSignals);
    if (!signalsValidation.success) {
      console.error('Invalid public signals:', signalsValidation.error.format());
      return false;
    }

    // Additional check for expected number of public signals (circuit specific)
    if (publicSignals.length !== 4) {
      console.error('Invalid publicSignals length:', publicSignals.length, '(expected 4)');
      return false;
    }

    // Convert proof to snarkjs format
    const snarkProof = {
      pi_a: proof.pi_a.slice(0, 2), // Remove the "1" at the end for snarkjs
      pi_b: [
        [proof.pi_b[0][1], proof.pi_b[0][0]], // Reverse order for snarkjs
        [proof.pi_b[1][1], proof.pi_b[1][0]],
      ],
      pi_c: proof.pi_c.slice(0, 2),
      protocol: proof.protocol,
      curve: proof.curve,
    };

    // Convert public signals to strings (snarkjs expects strings)
    const signals = publicSignals.map(s => s.toString());

    console.log('  ‚Üí Calling snarkjs.groth16.verify()...');
    
    // ACTUAL SNARKJS VERIFICATION
    // This is the real cryptographic verification!
    const isValid = await snarkjs.groth16.verify(
      VERIFICATION_KEY,
      signals,
      snarkProof
    );

    if (isValid) {
      console.log('  ‚úÖ Proof is cryptographically valid!');
    } else {
      console.log('  ‚ùå Proof verification failed!');
    }

    return isValid;
  } catch (error) {
    console.error('‚ùå Error verifying proof:', error);
    throw error;
  }
}

/**
 * Verify ticket validity period entirely in the browser
 */
export function verifyValidityPeriod(
  validFrom: string,
  validUntil: string
): { valid: boolean; message?: string } {
  const now = new Date();
  const ticketValidFrom = new Date(validFrom);
  const ticketValidUntil = new Date(validUntil);

  if (isNaN(ticketValidFrom.getTime()) || isNaN(ticketValidUntil.getTime())) {
    return {
      valid: false,
      message: 'Invalid date format',
    };
  }

  if (now < ticketValidFrom) {
    return {
      valid: false,
      message: `Ticket not yet valid. Valid from: ${ticketValidFrom.toLocaleString()}`,
    };
  }

  if (now > ticketValidUntil) {
    return {
      valid: false,
      message: `Ticket has expired. Valid until: ${ticketValidUntil.toLocaleString()}`,
    };
  }

  return {
    valid: true,
  };
}

/**
 * Complete offline ticket verification
 * This runs ENTIRELY in the browser - no backend communication
 */
export async function verifyTicketOffline(ticketData: QRCodeData): Promise<{
  valid: boolean;
  message: string;
  details?: any;
}> {
  console.log('üîí Offline verification - NO backend communication');
  console.log('üì¶ Ticket data:', {
    ticketId: ticketData.ticketId,
    routeId: ticketData.routeId,
    validFrom: ticketData.validFrom,
    validUntil: ticketData.validUntil,
  });

  // Step 1: Verify the cryptographic proof using REAL snarkjs verification
  console.log('  ‚Üí Step 1: Verifying ZK proof with snarkjs...');
  const isProofValid = await verifyProofOffline(
    ticketData.proof,
    ticketData.publicSignals
  );

  if (!isProofValid) {
    return {
      valid: false,
      message: 'Invalid cryptographic proof - ticket may be forged',
    };
  }
  console.log('  ‚úì ZK proof is cryptographically valid');

  // Step 2: Verify validity period
  console.log('  ‚Üí Step 2: Checking validity period...');
  const validityCheck = verifyValidityPeriod(
    ticketData.validFrom,
    ticketData.validUntil
  );

  if (!validityCheck.valid) {
    return {
      valid: false,
      message: validityCheck.message || 'Ticket not valid for current date/time',
    };
  }
  console.log('  ‚úì Ticket is within validity period');

  // All checks passed!
  console.log('‚úÖ Offline verification complete - ticket is VALID!');

  return {
    valid: true,
    message: 'Ticket is cryptographically valid (verified offline with snarkjs)',
    details: {
      ticketId: ticketData.ticketId,
      route: `Route ${ticketData.routeId}`,
      validUntil: ticketData.validUntil,
      verifiedAt: new Date().toISOString(),
      verificationMethod: 'client-side-snarkjs',
      cryptographicProof: 'verified',
    },
  };
}
